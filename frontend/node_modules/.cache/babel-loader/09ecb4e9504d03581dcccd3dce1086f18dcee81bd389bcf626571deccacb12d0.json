{"ast":null,"code":"import arbitor from \"../src/arbiter/arbiter.js\";\nexport const getCharacter = file => String.fromCharCode(file + 96);\nexport const createPosition = () => {\n  const position = new Array(8).fill(\"\").map(() => new Array(8).fill(\"\"));\n  for (let i = 0; i < 8; i++) {\n    position[6][i] = \"bp\";\n    position[1][i] = \"wp\";\n  }\n  position[0][0] = \"wr\";\n  position[0][1] = \"wn\";\n  position[0][2] = \"wb\";\n  position[0][3] = \"wq\";\n  position[0][4] = \"wk\";\n  position[0][5] = \"wb\";\n  position[0][6] = \"wn\";\n  position[0][7] = \"wr\";\n  position[7][0] = \"br\";\n  position[7][1] = \"bn\";\n  position[7][2] = \"bb\";\n  position[7][3] = \"bq\";\n  position[7][4] = \"bk\";\n  position[7][5] = \"bb\";\n  position[7][6] = \"bn\";\n  position[7][7] = \"br\";\n\n  /* This is a position that you can use to test the disambiguation of moves\n   * it has three white knights that can all move to the same square and you\n   * you should see that the moves are properly disambiguated.\n   *\n   * position[-1][0] = \"bk\";\n   * position[-1][7] = \"wk\";\n   * position[2][2] = \"wn\";\n   * position[2][6] = \"wn\";\n   * position[4][2] = \"wn\";\n   *\n   * Example: if you move the knight on g4 to e5, the notation was originally\n   * only \"Ne5\" but now it should be \"Nge5\" to signify which knight is moving.\n   *\n   * All cases should work, if you have two of the same pieces that can move to\n   * the same square, but they are on different files or ranks, the notation\n   * should be disambiguated by the file, rank, or file and rank, of the piece\n   * depending on where the ambiguity is.\n   *\n   * If you have two knights that can move to the same square, but they\n   * are on different files, the notation should be disambiguated by the file.\n   *\n   * If you have two knights that can move to the same square, but they are on\n   * the same file, the notation should be disambiguated by the rank.\n   *\n   * Take for example this opening:\n   * 1. e4 e5\n   * 2. Ne2 Nc6\n   * 3. Nbc3 ...\n   *\n   * Since we have two knights that can both move to the c3 square, we need to\n   * disambiguate the move. Disambiguating by the file takes priority.\n   *\n   * If you have two of the same pieces that are on the same file and can move to\n   * the same square, you would then disambiguate by the rank.\n   *\n   * In the rare case that you have three or more of the same piece that can all\n   * move to the same square and they share files and ranks, you would disambiguate\n   * by both the file and rank. If you move the knight on c3 to e5 in the provided\n   * position, the notation should be \"Nc3e5\" to signify that the knight on c3\n   * is moving to e5.\n   *\n   */\n\n  return position;\n};\nexport const copyPosition = position => {\n  const newPosition = new Array(8).fill(\"\").map(() => new Array(8).fill(\"\"));\n  for (let rank = 0; rank < position.length; rank++) {\n    for (let file = 0; file < position[0].length; file++) {\n      newPosition[rank][file] = position[rank][file];\n    }\n  }\n  return newPosition;\n};\nexport const areSameColorTiles = (coords1, coords2) => (coords1.x + coords1.y) % 2 === coords2.x + coords2.y;\nexport const findPieceCoords = (position, type) => {\n  let results = [];\n  position.forEach((rank, i) => {\n    rank.forEach((pos, j) => {\n      if (pos === type) results.push({\n        x: i,\n        y: j\n      });\n    });\n  });\n  return results;\n};\nexport const getNewMoveNotation = _ref => {\n  let {\n    piece,\n    rank,\n    file,\n    x,\n    y,\n    position,\n    previousPosition,\n    promotesTo\n  } = _ref;\n  let note = \"\";\n  const takes = position[x][y];\n  rank = Number(rank);\n  file = Number(file);\n  if (piece[1] === \"k\" && Math.abs(file - y) === 2) {\n    if (file < y) return \"O-O\";else return \"O-O-O\";\n  }\n  if (piece[1] !== \"p\") {\n    note += disambiguateMove(piece, position, previousPosition, rank, file, x, y, note, takes);\n  } else if (rank !== x && file !== y) {\n    note += getCharacter(file + 1) + \"x\";\n  }\n  note += getCharacter(y + 1) + (x + 1);\n  const positionAfterMove = arbitor.performMove({\n    position,\n    piece,\n    rank,\n    file,\n    x,\n    y\n  });\n  if (promotesTo) note += \"=\" + promotesTo.toUpperCase();\n  const mated = arbitor.isCheckMate(positionAfterMove, piece[0] === \"w\" ? \"b\" : \"w\", \"none\");\n  const checked = arbitor.isPlayerInCheck({\n    positionAfterMove: positionAfterMove,\n    position: position,\n    player: piece[0] === \"w\" ? \"b\" : \"w\"\n  });\n  if (mated) note += \"#\";else if (checked) note += \"+\";\n  return note;\n};\nexport const disambiguateMove = (piece, position, previousPosition, currX, currY, toX, toY, note, takes) => {\n  let ambiguousPieces = [];\n  const enemyColor = piece[0] === \"w\" ? \"b\" : \"w\";\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      if (position[rank][file] === \"\" || rank === currX && file === currY || position[rank][file][0] === enemyColor) {\n        continue;\n      } else if (position[rank][file] === piece) {\n        const pieceAtPositionValidMoves = arbitor.getValidMoves({\n          position: position,\n          prevPosition: previousPosition,\n          castleDirection: \"none\",\n          piece: position[rank][file],\n          rank,\n          file\n        });\n        if (pieceAtPositionValidMoves.some(_ref2 => {\n          let [x, y] = _ref2;\n          return x === toX && y === toY;\n        })) {\n          ambiguousPieces.push({\n            pieceAt: position[rank][file],\n            rank: rank,\n            file: file\n          });\n        }\n      }\n    }\n  }\n  const pieceLetter = piece[1].toUpperCase();\n  const fileChar = getCharacter(currY + 1);\n  const rankChar = (currX + 1).toString();\n  function appendTake(str) {\n    return takes !== \"\" ? str + \"x\" : str;\n  }\n  if (ambiguousPieces.length === 0) {\n    // No ambiguity, just return the piece letter\n    note += appendTake(pieceLetter);\n  } else if (ambiguousPieces.length === 1) {\n    // Only one ambiguous piece\n    if (ambiguousPieces[0].file !== currY) {\n      // try to disambiguate by file\n      note += appendTake(pieceLetter + fileChar);\n    } else {\n      // disambiguate by rank\n      note += appendTake(pieceLetter + rankChar);\n    }\n  } else {\n    // More than one ambiguous piece\n    let onFile = false;\n    let onRank = false;\n    ambiguousPieces.forEach(ambiguousPiece => {\n      // Check if the moving piece is on the same file or rank of an ambiguous piece\n      if (ambiguousPiece.file === currY) onFile = true;\n      if (ambiguousPiece.rank === currX) onRank = true;\n    });\n    if (onFile && onRank) {\n      // Disambiguate depending on both file and rank\n      note += appendTake(pieceLetter + fileChar + rankChar);\n    } else if (onFile) {\n      note += appendTake(pieceLetter + rankChar);\n    } else {\n      note += appendTake(pieceLetter + fileChar);\n    }\n  }\n  return note;\n};","map":{"version":3,"names":["arbitor","getCharacter","file","String","fromCharCode","createPosition","position","Array","fill","map","i","copyPosition","newPosition","rank","length","areSameColorTiles","coords1","coords2","x","y","findPieceCoords","type","results","forEach","pos","j","push","getNewMoveNotation","_ref","piece","previousPosition","promotesTo","note","takes","Number","Math","abs","disambiguateMove","positionAfterMove","performMove","toUpperCase","mated","isCheckMate","checked","isPlayerInCheck","player","currX","currY","toX","toY","ambiguousPieces","enemyColor","pieceAtPositionValidMoves","getValidMoves","prevPosition","castleDirection","some","_ref2","pieceAt","pieceLetter","fileChar","rankChar","toString","appendTake","str","onFile","onRank","ambiguousPiece"],"sources":["/home/fred/Desktop/projects/myrepertoire.io/src/helper.js"],"sourcesContent":["import arbitor from \"../src/arbiter/arbiter.js\";\n\nexport const getCharacter = (file) => String.fromCharCode(file + 96);\nexport const createPosition = () => {\n  const position = new Array(8).fill(\"\").map(() => new Array(8).fill(\"\"));\n\n  for (let i = 0; i < 8; i++) {\n    position[6][i] = \"bp\";\n    position[1][i] = \"wp\";\n  }\n\n  position[0][0] = \"wr\";\n  position[0][1] = \"wn\";\n  position[0][2] = \"wb\";\n  position[0][3] = \"wq\";\n  position[0][4] = \"wk\";\n  position[0][5] = \"wb\";\n  position[0][6] = \"wn\";\n  position[0][7] = \"wr\";\n\n  position[7][0] = \"br\";\n  position[7][1] = \"bn\";\n  position[7][2] = \"bb\";\n  position[7][3] = \"bq\";\n  position[7][4] = \"bk\";\n  position[7][5] = \"bb\";\n  position[7][6] = \"bn\";\n  position[7][7] = \"br\";\n\n  /* This is a position that you can use to test the disambiguation of moves\n   * it has three white knights that can all move to the same square and you\n   * you should see that the moves are properly disambiguated.\n   *\n   * position[-1][0] = \"bk\";\n   * position[-1][7] = \"wk\";\n   * position[2][2] = \"wn\";\n   * position[2][6] = \"wn\";\n   * position[4][2] = \"wn\";\n   *\n   * Example: if you move the knight on g4 to e5, the notation was originally\n   * only \"Ne5\" but now it should be \"Nge5\" to signify which knight is moving.\n   *\n   * All cases should work, if you have two of the same pieces that can move to\n   * the same square, but they are on different files or ranks, the notation\n   * should be disambiguated by the file, rank, or file and rank, of the piece\n   * depending on where the ambiguity is.\n   *\n   * If you have two knights that can move to the same square, but they\n   * are on different files, the notation should be disambiguated by the file.\n   *\n   * If you have two knights that can move to the same square, but they are on\n   * the same file, the notation should be disambiguated by the rank.\n   *\n   * Take for example this opening:\n   * 1. e4 e5\n   * 2. Ne2 Nc6\n   * 3. Nbc3 ...\n   *\n   * Since we have two knights that can both move to the c3 square, we need to\n   * disambiguate the move. Disambiguating by the file takes priority.\n   *\n   * If you have two of the same pieces that are on the same file and can move to\n   * the same square, you would then disambiguate by the rank.\n   *\n   * In the rare case that you have three or more of the same piece that can all\n   * move to the same square and they share files and ranks, you would disambiguate\n   * by both the file and rank. If you move the knight on c3 to e5 in the provided\n   * position, the notation should be \"Nc3e5\" to signify that the knight on c3\n   * is moving to e5.\n   *\n   */\n\n  return position;\n};\n\nexport const copyPosition = (position) => {\n  const newPosition = new Array(8).fill(\"\").map(() => new Array(8).fill(\"\"));\n\n  for (let rank = 0; rank < position.length; rank++) {\n    for (let file = 0; file < position[0].length; file++) {\n      newPosition[rank][file] = position[rank][file];\n    }\n  }\n\n  return newPosition;\n};\n\nexport const areSameColorTiles = (coords1, coords2) =>\n  (coords1.x + coords1.y) % 2 === coords2.x + coords2.y;\n\nexport const findPieceCoords = (position, type) => {\n  let results = [];\n  position.forEach((rank, i) => {\n    rank.forEach((pos, j) => {\n      if (pos === type) results.push({ x: i, y: j });\n    });\n  });\n  return results;\n};\n\nexport const getNewMoveNotation = ({\n  piece,\n  rank,\n  file,\n  x,\n  y,\n  position,\n  previousPosition,\n  promotesTo,\n}) => {\n  let note = \"\";\n  const takes = position[x][y];\n\n  rank = Number(rank);\n  file = Number(file);\n  if (piece[1] === \"k\" && Math.abs(file - y) === 2) {\n    if (file < y) return \"O-O\";\n    else return \"O-O-O\";\n  }\n\n  if (piece[1] !== \"p\") {\n    note += disambiguateMove(\n      piece,\n      position,\n      previousPosition,\n      rank,\n      file,\n      x,\n      y,\n      note,\n      takes,\n    );\n  } else if (rank !== x && file !== y) {\n    note += getCharacter(file + 1) + \"x\";\n  }\n\n  note += getCharacter(y + 1) + (x + 1);\n\n  const positionAfterMove = arbitor.performMove({\n    position,\n    piece,\n    rank,\n    file,\n    x,\n    y,\n  });\n\n  if (promotesTo) note += \"=\" + promotesTo.toUpperCase();\n\n  const mated = arbitor.isCheckMate(\n    positionAfterMove,\n    piece[0] === \"w\" ? \"b\" : \"w\",\n    \"none\",\n  );\n  const checked = arbitor.isPlayerInCheck({\n    positionAfterMove: positionAfterMove,\n    position: position,\n    player: piece[0] === \"w\" ? \"b\" : \"w\",\n  });\n\n  if (mated) note += \"#\";\n  else if (checked) note += \"+\";\n\n  return note;\n};\n\nexport const disambiguateMove = (\n  piece,\n  position,\n  previousPosition,\n  currX,\n  currY,\n  toX,\n  toY,\n  note,\n  takes,\n) => {\n  let ambiguousPieces = [];\n  const enemyColor = piece[0] === \"w\" ? \"b\" : \"w\";\n\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      if (\n        position[rank][file] === \"\" ||\n        (rank === currX && file === currY) ||\n        position[rank][file][0] === enemyColor\n      ) {\n        continue;\n      } else if (position[rank][file] === piece) {\n        const pieceAtPositionValidMoves = arbitor.getValidMoves({\n          position: position,\n          prevPosition: previousPosition,\n          castleDirection: \"none\",\n          piece: position[rank][file],\n          rank,\n          file,\n        });\n        if (\n          pieceAtPositionValidMoves.some(([x, y]) => x === toX && y === toY)\n        ) {\n          ambiguousPieces.push({\n            pieceAt: position[rank][file],\n            rank: rank,\n            file: file,\n          });\n        }\n      }\n    }\n  }\n\n  const pieceLetter = piece[1].toUpperCase();\n  const fileChar = getCharacter(currY + 1);\n  const rankChar = (currX + 1).toString();\n\n  function appendTake(str) {\n    return takes !== \"\" ? str + \"x\" : str;\n  }\n\n  if (ambiguousPieces.length === 0) {\n    // No ambiguity, just return the piece letter\n    note += appendTake(pieceLetter);\n  } else if (ambiguousPieces.length === 1) {\n    // Only one ambiguous piece\n    if (ambiguousPieces[0].file !== currY) {\n      // try to disambiguate by file\n      note += appendTake(pieceLetter + fileChar);\n    } else {\n      // disambiguate by rank\n      note += appendTake(pieceLetter + rankChar);\n    }\n  } else {\n    // More than one ambiguous piece\n    let onFile = false;\n    let onRank = false;\n    ambiguousPieces.forEach((ambiguousPiece) => {\n      // Check if the moving piece is on the same file or rank of an ambiguous piece\n      if (ambiguousPiece.file === currY) onFile = true;\n      if (ambiguousPiece.rank === currX) onRank = true;\n    });\n\n    if (onFile && onRank) {\n      // Disambiguate depending on both file and rank\n      note += appendTake(pieceLetter + fileChar + rankChar);\n    } else if (onFile) {\n      note += appendTake(pieceLetter + rankChar);\n    } else {\n      note += appendTake(pieceLetter + fileChar);\n    }\n  }\n\n  return note;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}