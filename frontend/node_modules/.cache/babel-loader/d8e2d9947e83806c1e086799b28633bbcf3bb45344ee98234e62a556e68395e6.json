{"ast":null,"code":"import arbitor from \"../src/arbiter/arbiter.js\";\nexport const getCharacter = file => String.fromCharCode(file + 96);\nexport const createPosition = () => {\n  const position = new Array(8).fill(\"\").map(() => new Array(8).fill(\"\"));\n  for (let i = 0; i < 8; i++) {\n    position[6][i] = \"bp\";\n    position[1][i] = \"wp\";\n  }\n  position[0][0] = \"wr\";\n  position[0][1] = \"wn\";\n  position[0][2] = \"wb\";\n  position[0][3] = \"wq\";\n  position[0][4] = \"wk\";\n  position[0][5] = \"wb\";\n  position[0][6] = \"wn\";\n  position[0][7] = \"wr\";\n  position[7][0] = \"br\";\n  position[7][1] = \"bn\";\n  position[7][2] = \"bb\";\n  position[7][3] = \"bq\";\n  position[7][4] = \"bk\";\n  position[7][5] = \"bb\";\n  position[7][6] = \"bn\";\n  position[7][7] = \"br\";\n\n  /* This is a position that you can use to test the disambiguation of moves\n   * it has three white knights that can all move to the same square and you\n   * you should see that the moves are properly disambiguated.\n   *\n   * position[-1][0] = \"bk\";\n   * position[-1][7] = \"wk\";\n   * position[2][2] = \"wn\";\n   * position[2][6] = \"wn\";\n   * position[4][2] = \"wn\";\n   *\n   * Example: if you move the knight on g4 to e5, the notation was originally\n   * only \"Ne5\" but now it should be \"Nge5\" to signify which knight is moving.\n   *\n   * All cases should work, if you have two of the same pieces that can move to\n   * the same square, but they are on different files or ranks, the notation\n   * should be disambiguated by the file, rank, or file and rank, of the piece\n   * depending on where the ambiguity is.\n   *\n   * If you have two knights that can move to the same square, but they\n   * are on different files, the notation should be disambiguated by the file.\n   *\n   * If you have two knights that can move to the same square, but they are on\n   * the same file, the notation should be disambiguated by the rank.\n   *\n   * Take for example this opening:\n   * 1. e4 e5\n   * 2. Ne2 Nc6\n   * 3. Nbc3 ...\n   *\n   * Since we have two knights that can both move to the c3 square, we need to\n   * disambiguate the move. Disambiguating by the file takes priority.\n   *\n   * If you have two of the same pieces that are on the same file and can move to\n   * the same square, you would then disambiguate by the rank.\n   *\n   * In the rare case that you have three or more of the same piece that can all\n   * move to the same square and they share files and ranks, you would disambiguate\n   * by both the file and rank. If you move the knight on c3 to e5 in the provided\n   * position, the notation should be \"Nc3e5\" to signify that the knight on c3\n   * is moving to e5.\n   *\n   */\n\n  return position;\n};\nexport const copyPosition = position => {\n  const newPosition = new Array(8).fill(\"\").map(() => new Array(8).fill(\"\"));\n  for (let rank = 0; rank < position.length; rank++) {\n    for (let file = 0; file < position[0].length; file++) {\n      newPosition[rank][file] = position[rank][file];\n    }\n  }\n  return newPosition;\n};\nexport const areSameColorTiles = (coords1, coords2) => (coords1.x + coords1.y) % 2 === coords2.x + coords2.y;\nexport const findPieceCoords = (position, type) => {\n  let results = [];\n  position.forEach((rank, i) => {\n    rank.forEach((pos, j) => {\n      if (pos === type) results.push({\n        x: i,\n        y: j\n      });\n    });\n  });\n  return results;\n};\nexport const getNewMoveNotation = _ref => {\n  let {\n    piece,\n    rank,\n    file,\n    x,\n    y,\n    position,\n    previousPosition,\n    promotesTo\n  } = _ref;\n  let note = \"\";\n  const takes = position[x][y];\n  rank = Number(rank);\n  file = Number(file);\n  if (piece[1] === \"k\" && Math.abs(file - y) === 2) {\n    if (file < y) return \"O-O\";else return \"O-O-O\";\n  }\n  if (piece[1] !== \"p\") {\n    note += disambiguateMove(piece, position, previousPosition, rank, file, x, y, note, takes);\n  } else if (rank !== x && file !== y) {\n    note += getCharacter(file + 1) + \"x\";\n  }\n  note += getCharacter(y + 1) + (x + 1);\n  const positionAfterMove = arbitor.performMove({\n    position,\n    piece,\n    rank,\n    file,\n    x,\n    y\n  });\n  if (promotesTo) note += \"=\" + promotesTo.toUpperCase();\n  const mated = arbitor.isCheckMate(positionAfterMove, piece[0] === \"w\" ? \"b\" : \"w\", \"none\");\n  const checked = arbitor.isPlayerInCheck({\n    positionAfterMove: positionAfterMove,\n    position: position,\n    player: piece[0] === \"w\" ? \"b\" : \"w\"\n  });\n  if (mated) note += \"#\";else if (checked) note += \"+\";\n  return note;\n};\nexport const disambiguateMove = (piece, position, previousPosition, currX, currY, toX, toY, note, takes) => {\n  let ambiguousPieces = [];\n  const enemyColor = piece[0] === \"w\" ? \"b\" : \"w\";\n  for (let rank = 0; rank < 8; rank++) {\n    for (let file = 0; file < 8; file++) {\n      if (position[rank][file] === \"\" || rank === currX && file === currY || position[rank][file][0] === enemyColor) {\n        continue;\n      } else if (position[rank][file] === piece) {\n        const pieceAtPositionValidMoves = arbitor.getValidMoves({\n          position: position,\n          prevPosition: previousPosition,\n          castleDirection: \"none\",\n          piece: position[rank][file],\n          rank,\n          file\n        });\n        if (pieceAtPositionValidMoves.some(_ref2 => {\n          let [x, y] = _ref2;\n          return x === toX && y === toY;\n        })) {\n          ambiguousPieces.push({\n            pieceAt: position[rank][file],\n            rank: rank,\n            file: file\n          });\n        }\n      }\n    }\n  }\n  const pieceLetter = piece[1].toUpperCase();\n  const fileChar = getCharacter(currY + 1);\n  const rankChar = (currX + 1).toString();\n  function appendTake(str) {\n    return takes !== \"\" ? str + \"x\" : str;\n  }\n  if (ambiguousPieces.length === 0) {\n    // No ambiguity, just return the piece letter\n    note += appendTake(pieceLetter);\n  } else if (ambiguousPieces.length === 1) {\n    // Only one ambiguous piece\n    if (ambiguousPieces[0].file !== currY) {\n      // try to disambiguate by file\n      note += appendTake(pieceLetter + fileChar);\n    } else {\n      // disambiguate by rank\n      note += appendTake(pieceLetter + rankChar);\n    }\n  } else {\n    // More than one ambiguous piece\n    let onFile = false;\n    let onRank = false;\n    ambiguousPieces.forEach(ambiguousPiece => {\n      // Check if the moving piece is on the same file or rank of an ambiguous piece\n      if (ambiguousPiece.file === currY) onFile = true;\n      if (ambiguousPiece.rank === currX) onRank = true;\n    });\n    if (onFile && onRank) {\n      // Disambiguate depending on both file and rank\n      note += appendTake(pieceLetter + fileChar + rankChar);\n    } else if (onFile) {\n      note += appendTake(pieceLetter + rankChar);\n    } else {\n      note += appendTake(pieceLetter + fileChar);\n    }\n  }\n  return note;\n};","map":{"version":3,"names":["arbitor","getCharacter","file","String","fromCharCode","createPosition","position","Array","fill","map","i","copyPosition","newPosition","rank","length","areSameColorTiles","coords1","coords2","x","y","findPieceCoords","type","results","forEach","pos","j","push","getNewMoveNotation","_ref","piece","previousPosition","promotesTo","note","takes","Number","Math","abs","disambiguateMove","positionAfterMove","performMove","toUpperCase","mated","isCheckMate","checked","isPlayerInCheck","player","currX","currY","toX","toY","ambiguousPieces","enemyColor","pieceAtPositionValidMoves","getValidMoves","prevPosition","castleDirection","some","_ref2","pieceAt","pieceLetter","fileChar","rankChar","toString","appendTake","str","onFile","onRank","ambiguousPiece"],"sources":["/home/fred/Desktop/projects/myrepertoire.io/frontend/src/helper.js"],"sourcesContent":["import arbitor from \"../src/arbiter/arbiter.js\";\n\nexport const getCharacter = (file) => String.fromCharCode(file + 96);\nexport const createPosition = () => {\n    const position = new Array(8).fill(\"\").map(() => new Array(8).fill(\"\"));\n\n    for (let i = 0; i < 8; i++) {\n        position[6][i] = \"bp\";\n        position[1][i] = \"wp\";\n    }\n\n    position[0][0] = \"wr\";\n    position[0][1] = \"wn\";\n    position[0][2] = \"wb\";\n    position[0][3] = \"wq\";\n    position[0][4] = \"wk\";\n    position[0][5] = \"wb\";\n    position[0][6] = \"wn\";\n    position[0][7] = \"wr\";\n\n    position[7][0] = \"br\";\n    position[7][1] = \"bn\";\n    position[7][2] = \"bb\";\n    position[7][3] = \"bq\";\n    position[7][4] = \"bk\";\n    position[7][5] = \"bb\";\n    position[7][6] = \"bn\";\n    position[7][7] = \"br\";\n\n    /* This is a position that you can use to test the disambiguation of moves\n     * it has three white knights that can all move to the same square and you\n     * you should see that the moves are properly disambiguated.\n     *\n     * position[-1][0] = \"bk\";\n     * position[-1][7] = \"wk\";\n     * position[2][2] = \"wn\";\n     * position[2][6] = \"wn\";\n     * position[4][2] = \"wn\";\n     *\n     * Example: if you move the knight on g4 to e5, the notation was originally\n     * only \"Ne5\" but now it should be \"Nge5\" to signify which knight is moving.\n     *\n     * All cases should work, if you have two of the same pieces that can move to\n     * the same square, but they are on different files or ranks, the notation\n     * should be disambiguated by the file, rank, or file and rank, of the piece\n     * depending on where the ambiguity is.\n     *\n     * If you have two knights that can move to the same square, but they\n     * are on different files, the notation should be disambiguated by the file.\n     *\n     * If you have two knights that can move to the same square, but they are on\n     * the same file, the notation should be disambiguated by the rank.\n     *\n     * Take for example this opening:\n     * 1. e4 e5\n     * 2. Ne2 Nc6\n     * 3. Nbc3 ...\n     *\n     * Since we have two knights that can both move to the c3 square, we need to\n     * disambiguate the move. Disambiguating by the file takes priority.\n     *\n     * If you have two of the same pieces that are on the same file and can move to\n     * the same square, you would then disambiguate by the rank.\n     *\n     * In the rare case that you have three or more of the same piece that can all\n     * move to the same square and they share files and ranks, you would disambiguate\n     * by both the file and rank. If you move the knight on c3 to e5 in the provided\n     * position, the notation should be \"Nc3e5\" to signify that the knight on c3\n     * is moving to e5.\n     *\n     */\n\n    return position;\n};\n\nexport const copyPosition = (position) => {\n    const newPosition = new Array(8).fill(\"\").map(() => new Array(8).fill(\"\"));\n\n    for (let rank = 0; rank < position.length; rank++) {\n        for (let file = 0; file < position[0].length; file++) {\n            newPosition[rank][file] = position[rank][file];\n        }\n    }\n\n    return newPosition;\n};\n\nexport const areSameColorTiles = (coords1, coords2) =>\n    (coords1.x + coords1.y) % 2 === coords2.x + coords2.y;\n\nexport const findPieceCoords = (position, type) => {\n    let results = [];\n    position.forEach((rank, i) => {\n        rank.forEach((pos, j) => {\n            if (pos === type) results.push({ x: i, y: j });\n        });\n    });\n    return results;\n};\n\nexport const getNewMoveNotation = ({\n    piece,\n    rank,\n    file,\n    x,\n    y,\n    position,\n    previousPosition,\n    promotesTo,\n}) => {\n    let note = \"\";\n    const takes = position[x][y];\n\n    rank = Number(rank);\n    file = Number(file);\n    if (piece[1] === \"k\" && Math.abs(file - y) === 2) {\n        if (file < y) return \"O-O\";\n        else return \"O-O-O\";\n    }\n\n    if (piece[1] !== \"p\") {\n        note += disambiguateMove(piece, position, previousPosition, rank, file, x, y, note, takes,);\n    } else if (rank !== x && file !== y) {\n        note += getCharacter(file + 1) + \"x\";\n    }\n\n    note += getCharacter(y + 1) + (x + 1);\n\n    const positionAfterMove = arbitor.performMove({\n        position,\n        piece,\n        rank,\n        file,\n        x,\n        y,\n    });\n\n    if (promotesTo) note += \"=\" + promotesTo.toUpperCase();\n\n    const mated = arbitor.isCheckMate(\n        positionAfterMove,\n        piece[0] === \"w\" ? \"b\" : \"w\",\n        \"none\",\n    );\n    const checked = arbitor.isPlayerInCheck({\n        positionAfterMove: positionAfterMove,\n        position: position,\n        player: piece[0] === \"w\" ? \"b\" : \"w\",\n    });\n\n    if (mated) note += \"#\";\n    else if (checked) note += \"+\";\n\n    return note;\n};\n\nexport const disambiguateMove = (piece, position, previousPosition, currX, currY, toX, toY, note, takes,) => {\n    let ambiguousPieces = [];\n    const enemyColor = piece[0] === \"w\" ? \"b\" : \"w\";\n\n    for (let rank = 0; rank < 8; rank++) {\n        for (let file = 0; file < 8; file++) {\n            if (position[rank][file] === \"\" || (rank === currX && file === currY) || position[rank][file][0] === enemyColor) {\n                continue;\n            } else if (position[rank][file] === piece) {\n                const pieceAtPositionValidMoves = arbitor.getValidMoves({\n                    position: position,\n                    prevPosition: previousPosition,\n                    castleDirection: \"none\",\n                    piece: position[rank][file],\n                    rank,\n                    file,\n                });\n                if (\n                    pieceAtPositionValidMoves.some(([x, y]) => x === toX && y === toY)\n                ) {\n                    ambiguousPieces.push({\n                        pieceAt: position[rank][file],\n                        rank: rank,\n                        file: file,\n                    });\n                }\n            }\n        }\n    }\n\n    const pieceLetter = piece[1].toUpperCase();\n    const fileChar = getCharacter(currY + 1);\n    const rankChar = (currX + 1).toString();\n\n    function appendTake(str) {\n        return takes !== \"\" ? str + \"x\" : str;\n    }\n\n    if (ambiguousPieces.length === 0) {\n        // No ambiguity, just return the piece letter\n        note += appendTake(pieceLetter);\n    } else if (ambiguousPieces.length === 1) {\n        // Only one ambiguous piece\n        if (ambiguousPieces[0].file !== currY) {\n            // try to disambiguate by file\n            note += appendTake(pieceLetter + fileChar);\n        } else {\n            // disambiguate by rank\n            note += appendTake(pieceLetter + rankChar);\n        }\n    } else {\n        // More than one ambiguous piece\n        let onFile = false;\n        let onRank = false;\n        ambiguousPieces.forEach((ambiguousPiece) => {\n            // Check if the moving piece is on the same file or rank of an ambiguous piece\n            if (ambiguousPiece.file === currY) onFile = true;\n            if (ambiguousPiece.rank === currX) onRank = true;\n        });\n\n        if (onFile && onRank) {\n            // Disambiguate depending on both file and rank\n            note += appendTake(pieceLetter + fileChar + rankChar);\n        } else if (onFile) {\n            note += appendTake(pieceLetter + rankChar);\n        } else {\n            note += appendTake(pieceLetter + fileChar);\n        }\n    }\n\n    return note;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}