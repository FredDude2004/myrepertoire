import "./Pieces.css";
import Piece from "./Piece";
import { useRef } from "react";
import { useAppContext } from "../../contexts/Context";
import { openPromotion } from "../../reducer/actions/popup";
import { getCastlingDirections } from "../../arbiter/getMoves";
import {
    updateCastling,
    detectStalemate,
    detectInsufficientMaterial,
    detectCheckmate,
} from "../../reducer/actions/game";
import { makeNewMove, clearCandidates, incrementStrikes } from "../../reducer/actions/move";
import arbiter from "../../arbiter/arbiter";
import { getNewMoveNotation, getPositionFromNotation, getOpponentMove, isMoveCorrect } from "../../lib/helper";
import { incrementVariationIdx, incrementLineIdx, incrementSelectedIdx } from "@/reducer/actions/lines";

const Pieces = () => {
    const { appState, dispatch } = useAppContext();
    const currentPosition = appState.position[appState.currentPositionIndex];
    const previousePosition = appState.position[appState.currentPositionIndex - 1];
    const ref = useRef();

    const updateCastlingState = ({ piece, file, rank }) => {
        const direction = getCastlingDirections({
            castleDirection: appState.castleDirection,
            piece,
            file,
            rank,
        });
        if (direction) {
            dispatch(updateCastling(direction));
        }
    };

    const openPromotionBox = ({ rank, file, x, y }) => {
        dispatch(
            openPromotion({
                rank: Number(rank),
                file: Number(file),
                x,
                y,
            }),
        );
    };

    const calculateCoords = (e) => {
        const { top, left, width } = ref.current.getBoundingClientRect();
        const size = width / 8;
        let rank = 7 - Math.floor((e.clientY - top) / size);
        let file = Math.floor((e.clientX - left) / size);

        if (appState.isFlipped) {
            rank = 7 - rank;
            file = 7 - file;
        }

        return { x: rank, y: file };
    };

    const move = (e) => {
        const { x, y } = calculateCoords(e);
        const [piece, rank, file] = e.dataTransfer.getData("text").split(",");

        if (appState.candidateMoves.find((m) => m[0] === x && m[1] === y)) {
            const opponentColor = piece.startsWith("b") ? "w" : "b";
            const castleDirection =
                appState.castleDirection[
                `${piece.startsWith("b") ? "white" : "black"}`
                ];

            if ((piece === "wp" && x === 7) || (piece === "bp" && x === 0)) {
                openPromotionBox({ rank, file, x, y });
                return;
            }
            if (piece.endsWith("r") || piece.endsWith("k")) {
                updateCastlingState({ piece, file, rank });
            }
            const newPosition = arbiter.performMove({
                position: currentPosition,
                piece,
                rank,
                file,
                x,
                y,
            });
            const newMove = getNewMoveNotation({
                piece,
                rank,
                file,
                x,
                y,
                position: currentPosition,
                previousPosition: previousePosition,
            });

            let moveNum = appState.moveNum;

            if (!isMoveCorrect(newMove, moveNum, piece[0], appState.currentVariation)) {
                dispatch(incrementStrikes());
                dispatch(clearCandidates());
                return;
            }

            dispatch(makeNewMove({ newPosition: newPosition, newMove: newMove }));

            if (arbiter.insufficientMaterial(newPosition))
                dispatch(detectInsufficientMaterial());
            else if (arbiter.isStalemate(newPosition, opponentColor, castleDirection)) {
                dispatch(detectStalemate());
            } else if (arbiter.isCheckMate(newPosition, opponentColor, castleDirection)) {
                dispatch(detectCheckmate(piece[0]));
            }

            if (!("black" in appState.currentVariation[moveNum - 1]) ||
                moveNum === appState.currentVariation.length) {
                dispatch(incrementVariationIdx());
                dispatch(clearCandidates());
                return;
            }


            if (opponentColor === "w") { // if the player is black need to make sure we are on second move
                moveNum++;
            }
            const opponentMove = getOpponentMove(moveNum, piece[0], appState.currentVariation);
            const opponentMoveInfo = getPositionFromNotation(newPosition, currentPosition, opponentMove, "both", opponentColor);
            const newNewPosition = arbiter.performMove({
                position: newPosition,
                piece: opponentMoveInfo.piece,
                rank: opponentMoveInfo.rank,
                file: opponentMoveInfo.file,
                x: opponentMoveInfo.x,
                y: opponentMoveInfo.y,
            });

            dispatch(makeNewMove({ newPosition: newNewPosition, newMove: opponentMove }));

            if (arbiter.insufficientMaterial(newNewPosition))
                dispatch(detectInsufficientMaterial());
            else if (arbiter.isStalemate(newNewPosition, piece[0], castleDirection)) {
                dispatch(detectStalemate());
            } else if (arbiter.isCheckMate(newNewPosition, piece[0], castleDirection)) {
                dispatch(detectCheckmate(piece[0]));
            }
        }
        dispatch(clearCandidates());

        if (appState.variationIdx < appState.currentVariation.length - 1) {
            dispatch(incrementVariationIdx());
        } else if (appState.currentIdx < appState.currentLine.length - 1) {
            dispatch(incrementLineIdx());
        } else if (appState.selectedIdx < appState.selectedLines.length - 1) {
            dispatch(incrementSelectedIdx());
        } else {
        }
    };

    const onDrop = (e) => {
        e.preventDefault();

        move(e);
    };

    const onDragOver = (e) => {
        e.preventDefault();
    };


    return (
        <div className="pieces" ref={ref} onDrop={onDrop} onDragOver={onDragOver}>
            {currentPosition.map((r, rank) =>
                r.map((f, file) => {
                    if (!currentPosition[rank][file]) return null;

                    // Calculate display coordinates per piece
                    const displayRank = appState.isFlipped ? 7 - rank : rank;
                    const displayFile = appState.isFlipped ? 7 - file : file;

                    return (
                        <Piece
                            key={rank + "-" + file}
                            rank={displayRank}         // for CSS positioning
                            file={displayFile}         // for CSS positioning
                            logicRank={rank}           // original board coords for move logic
                            logicFile={file}           // original board coords for move logic
                            piece={currentPosition[rank][file]}
                        />
                    );
                })
            )}
        </div>
    );
};

export default Pieces;

